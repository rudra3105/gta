/*!
 * ScrollToPlugin 3.11.4
 * https://gsap.com
 *
 * @license Copyright 2022, GreenSock. All rights reserved.
 * This plugin is a membership benefit of Club GreenSock and is only authorized for use in sites/apps/products developed by individuals/companies with an active Club GreenSock membership. See https://greensock.com/club
 * @author: Jack Doyle, jack@greensock.com
 */
! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {})
}(this, function(e) {
    "use strict";

    function t(e, t) {
        for (var _ = 0; _ < t.length; _++) {
            var r = t[_];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function _() {
        return "undefined" != typeof window
    }

    function r() {
        return u || _() && (u = window.gsap) && u.registerPlugin && u
    }

    function n() {
        return String.fromCharCode.apply(null, arguments)
    }

    function o(e) {
        return b.maxScroll(e || p)
    }
    var i, s, a, $, l, c, f, u, d, p, h, g, v, m, y, b, w, S, T, x, C, E, P = n(103, 114, 101, 101, 110, 115, 111, 99, 107, 46, 99, 111, 109),
        k = n(103, 115, 97, 112, 46, 99, 111, 109),
        R = (i = "undefined" != typeof window ? window.location.host : "", $ = (a = (0 === ((s = "undefined" != typeof window) ? window.location.href : "").indexOf(n(102, 105, 108, 101, 58, 47, 47)) || -1 !== i.indexOf(n(108, 111, 99, 97, 108, 104, 111, 115, 116)) || /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}:?\d*$/.test(i) || ((s ? window.location.hostname : "").split(".").pop(), n(108, 111, 99, 97, 108)), [P, k, n(99, 111, 100, 101, 112, 101, 110, 46, 105, 111), n(99, 111, 100, 101, 112, 101, 110, 46, 112, 108, 117, 109, 98, 105, 110, 103), n(99, 111, 100, 101, 112, 101, 110, 46, 100, 101, 118), n(99, 111, 100, 101, 112, 101, 110, 46, 97, 112, 112), n(99, 111, 100, 101, 112, 101, 110, 46, 119, 101, 98, 115, 105, 116, 101), n(112, 101, 110, 115, 46, 99, 108, 111, 117, 100), n(99, 115, 115, 45, 116, 114, 105, 99, 107, 115, 46, 99, 111, 109), n(99, 100, 112, 110, 46, 105, 111), n(112, 101, 110, 115, 46, 105, 111), n(103, 97, 110, 110, 111, 110, 46, 116, 118), n(99, 111, 100, 101, 99, 97, 110, 121, 111, 110, 46, 110, 101, 116), n(116, 104, 101, 109, 101, 102, 111, 114, 101, 115, 116, 46, 110, 101, 116), n(99, 101, 114, 101, 98, 114, 97, 120, 46, 99, 111, 46, 117, 107), n(116, 121, 109, 112, 97, 110, 117, 115, 46, 110, 101, 116), n(116, 119, 101, 101, 110, 109, 97, 120, 46, 99, 111, 109), n(112, 108, 110, 107, 114, 46, 99, 111), n(104, 111, 116, 106, 97, 114, 46, 99, 111, 109), n(119, 101, 98, 112, 97, 99, 107, 98, 105, 110, 46, 99, 111, 109), n(97, 114, 99, 104, 105, 118, 101, 46, 111, 114, 103), n(99, 111, 100, 101, 115, 97, 110, 100, 98, 111, 120, 46, 105, 111), n(99, 115, 98, 46, 97, 112, 112), n(115, 116, 97, 99, 107, 98, 108, 105, 116, 122, 46, 99, 111, 109), n(115, 116, 97, 99, 107, 98, 108, 105, 116, 122, 46, 105, 111), n(99, 111, 100, 105, 101, 114, 46, 105, 111), n(109, 111, 116, 105, 111, 110, 116, 114, 105, 99, 107, 115, 46, 99, 111, 109), n(115, 116, 97, 99, 107, 111, 118, 101, 114, 102, 108, 111, 119, 46, 99, 111, 109), n(115, 116, 97, 99, 107, 101, 120, 99, 104, 97, 110, 103, 101, 46, 99, 111, 109), n(115, 116, 117, 100, 105, 111, 102, 114, 101, 105, 103, 104, 116, 46, 99, 111, 109), n(119, 101, 98, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 105, 111), n(106, 115, 102, 105, 100, 100, 108, 101, 46, 110, 101, 116), ])).length, i.indexOf(a[$]), A.register = function e(t) {
            return d || (u = t || r(), _() && window.document && (p = window, g = (h = document).documentElement, v = h.body), u && (m = u.utils.toArray, y = u.utils.clamp, S = u.parseEase("expo"), C = u.core.context || function() {}, b = u.core.globals().ScrollTrigger, u.core.globals("ScrollSmoother", A), v && b && (E = u.delayedCall(.2, function() {
                return b.isRefreshing || w && w.refresh()
            }).pause(), T = b.core._getVelocityProp, x = b.core._inputObserver, A.refresh = b.refresh, d = 1))), d
        }, l = A, c = [{
            key: "progress",
            get: function e() {
                return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0
            }
        }, ], t(l.prototype, c), f && t(l, f), A);

    function A(e) {
        var t = this;

        function _() {
            return el.update(-es)
        }

        function r() {
            return B.style.overflow = "visible"
        }

        function n(e) {
            e.update();
            var t = e.getTween();
            t && (t.pause(), t._time = t._dur, t._tTime = t._tDur), K = !1, e.animation.progress(e.progress, !0)
        }

        function i(e, t) {
            (e !== es && !M || t) && (et && (e = Math.round(e)), eo && (B.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + e + ", 0, 1)", B._gsap.y = e + "px"), ea = e - es, es = e, b.isUpdating || A.isRefreshing || b.update())
        }

        function s(e) {
            return arguments.length ? (e < 0 && (e = 0), ec.y = -e, K = !0, M ? es = -e : i(-e), b.isRefreshing ? L.update() : en(e / ei), this) : -es
        }

        function a(e) {
            H.scrollTop = 0, e.target.contains && e.target.contains(H) || Z && !1 === Z(t, e) || (b.isInViewport(e.target) || e.target === W || t.scrollTo(e.target, !1, "center center"), W = e.target)
        }

        function $(e, t) {
            if (e < t.start) return e;
            var _ = isNaN(t.ratio) ? 1 : t.ratio,
                r = t.end - t.start,
                n = e - t.start,
                i = t.offset || 0,
                s = t.pins || [],
                a = s.offset || 0,
                $ = t._startClamp && t.start <= 0 || t.pins && t.pins.offset ? 0 : t._endClamp && t.end === o() ? 1 : .5;
            return s.forEach(function(t) {
                r -= t.distance, t.nativeStart <= e && (n -= t.distance)
            }), a && (n *= (r - a / _) / r), e + (n - i * $) / _ - n
        }

        function l(e, t) {
            O.forEach(function(_) {
                return function e(t, _, r) {
                    r || (t.pins.length = t.pins.offset = 0);
                    var n, o, i, s, a, l, c, f, d = t.pins,
                        p = t.markers;
                    for (c = 0; c < _.length; c++)
                        if (f = _[c], t.trigger && f.trigger && t !== f && (f.trigger === t.trigger || f.pinnedContainer === t.trigger || t.trigger.contains(f.trigger)) && (a = f._startNative || f._startClamp || f.start, l = f._endNative || f._endClamp || f.end, i = $(a, t), s = f.pin && 0 < l ? i + (l - a) : $(l, t), f.setPositions(i, s, !0, (f._startClamp ? Math.max(0, i) : i) - a), f.markerStart && p.push(u.quickSetter([f.markerStart, f.markerEnd], "y", "px")), f.pin && 0 < f.end && !r)) {
                            if (n = f.end - f.start, o = t._startClamp && f.start < 0) {
                                if (0 < t.start) return t.setPositions(0, t.end + (t._startNative - t.start), !0), void e(t, _);
                                n += f.start, d.offset = -f.start
                            }
                            d.push({
                                start: f.start,
                                nativeStart: a,
                                end: f.end,
                                distance: n,
                                trig: f
                            }), t.setPositions(t.start, t.end + (o ? -f.start : n), !0)
                        }
                }(_, e, t)
            })
        }

        function c() {
            r(), requestAnimationFrame(r), O && (b.getAll().forEach(function(e) {
                e._startNative = e.start, e._endNative = e.end
            }), O.forEach(function(e) {
                var t = e._startClamp || e.start,
                    _ = e.autoSpeed ? Math.min(o(), e.end) : t + Math.abs((e.end - t) / e.ratio),
                    r = _ - e.end;
                if ((_ -= r / 2) < (t -= r / 2)) {
                    var n = t;
                    t = _, _ = n
                }
                e._startClamp && t < 0 ? (r = (_ = e.ratio < 0 ? o() : e.end / e.ratio) - e.end, t = 0) : (e.ratio < 0 || e._endClamp && _ >= o()) && (r = ((_ = o()) - (t = e.ratio < 0 || 1 < e.ratio ? 0 : _ - (_ - e.start) / e.ratio)) * e.ratio - (e.end - e.start)), e.offset = r || 1e-4, e.pins.length = e.pins.offset = 0, e.setPositions(t, _, !0)
            }), l(b.sort())), el.reset()
        }

        function f() {
            return b.addEventListener("refresh", c)
        }

        function P() {
            return O && O.forEach(function(e) {
                return e.vars.onRefresh(e)
            })
        }

        function k() {
            return O && O.forEach(function(e) {
                return e.vars.onRefreshInit(e)
            }), P
        }

        function R(e, t, _, r) {
            return function() {
                var n = "function" == typeof t ? t(_, r) : t;
                n || 0 === n || (n = r.getAttribute("data-" + er + e) || ("speed" === e ? 1 : 0)), r.setAttribute("data-" + er + e, n);
                var o = "clamp(" === (n + "").substr(0, 6);
                return {
                    clamp: o,
                    value: o ? n.substr(6, n.length - 7) : n
                }
            }
        }

        function z(e, t, _, r, n) {
            function i() {
                t = v(), _ = parseFloat(m().value), $ = parseFloat(t.value) || 1, d = (c = "auto" === t.value) || l && l._startClamp && l.start <= 0 || x.offset ? 0 : l && l._endClamp && l.end === o() ? 1 : .5, f && f.kill(), f = _ && u.to(e, {
                    ease: S,
                    overwrite: !1,
                    y: "+=0",
                    duration: _
                }), l && (l.ratio = $, l.autoSpeed = c)
            }

            function s() {
                T.y = w + "px", T.renderTransform(1), i()
            }

            function a(t) {
                if (c) {
                    s();
                    var _, r, n, o, i, a, l, u, d, v, m, b = (_ = e, r = y(0, 1, -t.start / (t.end - t.start)), i = _.parentNode || g, a = _.getBoundingClientRect(), u = (l = i.getBoundingClientRect()).top - a.top, m = -(v = (Math.abs(u) > Math.abs(d = l.bottom - a.bottom) ? u : d) / (1 - r)) * r, 0 < v && (o = .5 == (n = l.height / (p.innerHeight + l.height)) ? 2 * l.height : 2 * Math.min(l.height, Math.abs(-v * n / (2 * n - 1))) * (r || 1), m += r ? -o * r : -o / 2, v += o), {
                        change: v,
                        offset: m
                    });
                    E = b.change, h = b.offset
                } else h = x.offset || 0, E = (t.end - t.start - h) * (1 - $);
                x.forEach(function(e) {
                    return E -= e.distance * (1 - $)
                }), t.offset = E || .001, t.vars.onUpdate(t), f && f.progress(1)
            }
            n = ("function" == typeof n ? n(r, e) : n) || 0;
            var $, l, c, f, d, h, v = R("speed", t, r, e),
                m = R("lag", _, r, e),
                w = u.getProperty(e, "y"),
                T = e._gsap,
                x = [],
                C = [],
                E = 0;
            return i(), (1 !== $ || c || f) && (a(l = b.create({
                trigger: c ? e.parentNode : e,
                start: function e() {
                    return t.clamp ? "clamp(top bottom+=" + n + ")" : "top bottom+=" + n
                },
                end: function e() {
                    return t.value < 0 ? "max" : t.clamp ? "clamp(bottom top-=" + n + ")" : "bottom top-=" + n
                },
                scroller: H,
                scrub: !0,
                refreshPriority: -999,
                onRefreshInit: s,
                onRefresh: a,
                onKill: function e(t) {
                    var _ = O.indexOf(t);
                    0 <= _ && O.splice(_, 1), s()
                },
                onUpdate: function e(t) {
                    var _, r, n, o, i = w + E * (t.progress - d),
                        s = x.length,
                        a = 0;
                    if (t.offset) {
                        if (s) {
                            for (n = -es, o = t.end; s--;) {
                                if ((r = x[s]).trig.isActive || n >= r.start && n <= r.end) return void(f && (r.trig.progress += r.trig.direction < 0 ? .001 : -.001, r.trig.update(0, 0, 1), f.resetTo("y", parseFloat(T.y), -ea, !0), e$ && f.progress(1)));
                                n > r.end && (a += r.distance), o -= r.distance
                            }
                            i = w + a + E * ((u.utils.clamp(t.start, t.end, n) - t.start - a) / (o - t.start) - d)
                        }
                        C.length && !c && C.forEach(function(e) {
                            return e(i - a)
                        }), i = Math.round(1e5 * (_ = i + h)) / 1e5 || 0, f ? (f.resetTo("y", i, -ea, !0), e$ && f.progress(1)) : (T.y = i + "px", T.renderTransform(1))
                    }
                }
            })), u.core.getCache(l.trigger).stRevert = k, l.startY = w, l.pins = x, l.markers = C, l.ratio = $, l.autoSpeed = c, e.style.willChange = "transform"), l
        }
        d || A.register(u) || console.warn("Please gsap.registerPlugin(ScrollSmoother)"), e = this.vars = e || {}, w && w.kill(), C(w = this);
        var B, H, N, L, O, I, U, V, D, M, q, F, Y, j, K, W, G = e.smoothTouch,
            J = e.onUpdate,
            Q = e.onStop,
            X = e.smooth,
            Z = e.onFocusIn,
            ee = e.normalizeScroll,
            et = e.wholePixels,
            e_ = this,
            er = e.effectsPrefix || "",
            en = b.getScrollFunc(p),
            eo = 1 === b.isTouch ? !0 === G ? .8 : parseFloat(G) || 0 : 0 === X || !1 === X ? 0 : parseFloat(X) || .8,
            ei = eo && +e.speed || 1,
            es = 0,
            ea = 0,
            e$ = 1,
            el = T(0),
            ec = {
                y: 0
            },
            ef = "undefined" != typeof ResizeObserver && !1 !== e.autoResize && new ResizeObserver(function() {
                if (!b.isRefreshing) {
                    var e = o(H) * ei;
                    e < -es && s(e), E.restart(!0)
                }
            });

        function eu() {
            return N = B.clientHeight, B.style.overflow = "visible", v.style.height = p.innerHeight + (N - p.innerHeight) / ei + "px", N - p.innerHeight
        }
        f(), b.addEventListener("killAll", f), u.delayedCall(.5, function() {
            return e$ = 0
        }), this.scrollTop = s, this.scrollTo = function(e, _, r) {
            var n = u.utils.clamp(0, o(), isNaN(e) ? t.offset(e, r, !!_ && !M) : +e);
            _ ? M ? u.to(t, {
                duration: eo,
                scrollTop: n,
                overwrite: "auto",
                ease: S
            }) : en(n) : s(n)
        }, this.offset = function(e, t, _) {
            var r, n = (e = m(e)[0]).style.cssText,
                o = b.create({
                    trigger: e,
                    start: t || "top top"
                });
            return O && (e$ ? b.refresh() : l([o], !0)), r = o.start / (_ ? ei : 1), o.kill(!1), e.style.cssText = n, u.core.getCache(e).uncache = 1, r
        }, this.content = function(e) {
            if (arguments.length) {
                var t = m(e || "#smooth-content")[0] || console.warn("ScrollSmoother needs a valid content element.") || v.children[0];
                return t !== B && (D = (B = t).getAttribute("style") || "", ef && ef.observe(B), u.set(B, {
                    overflow: "visible",
                    width: "100%",
                    boxSizing: "border-box",
                    y: "+=0"
                }), eo || u.set(B, {
                    clearProps: "transform"
                })), this
            }
            return B
        }, this.wrapper = function(e) {
            var t, _;
            return arguments.length ? (V = (H = m(e || "#smooth-wrapper")[0] || (t = B, (_ = h.querySelector(".ScrollSmoother-wrapper")) || ((_ = h.createElement("div")).classList.add("ScrollSmoother-wrapper"), t.parentNode.insertBefore(_, t), _.appendChild(t)), _)).getAttribute("style") || "", eu(), u.set(H, eo ? {
                overflow: "hidden",
                position: "fixed",
                height: "100%",
                width: "100%",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            } : {
                overflow: "visible",
                position: "relative",
                width: "100%",
                height: "auto",
                top: "auto",
                bottom: "auto",
                left: "auto",
                right: "auto"
            }), this) : H
        }, this.effects = function(e, t) {
            if (O = O || [], !e) return O.slice(0);
            (e = m(e)).forEach(function(e) {
                for (var t = O.length; t--;) O[t].trigger === e && O[t].kill()
            });
            var _, r, n = (t = t || {}).speed,
                o = t.lag,
                i = t.effectsPadding,
                s = [];
            for (_ = 0; _ < e.length; _++)(r = z(e[_], n, o, _, i)) && s.push(r);
            return O.push.apply(O, s), !1 !== t.refresh && b.refresh(), s
        }, this.sections = function(e, t) {
            if (I = I || [], !e) return I.slice(0);
            var _ = m(e).map(function(e) {
                return b.create({
                    trigger: e,
                    start: "top 120%",
                    end: "bottom -20%",
                    onToggle: function t(_) {
                        e.style.opacity = _.isActive ? "1" : "0", e.style.pointerEvents = _.isActive ? "all" : "none"
                    }
                })
            });
            return t && t.add ? I.push.apply(I, _) : I = _.slice(0), _
        }, this.content(e.content), this.wrapper(e.wrapper), this.render = function(e) {
            return i(e || 0 === e ? e : es)
        }, this.getVelocity = function() {
            return el.getVelocity(-es)
        }, b.scrollerProxy(H, {
            scrollTop: s,
            scrollHeight: function e() {
                return eu() && v.scrollHeight
            },
            fixedMarkers: !1 !== e.fixedMarkers && !!eo,
            content: B,
            getBoundingClientRect: function e() {
                return {
                    top: 0,
                    left: 0,
                    width: p.innerWidth,
                    height: p.innerHeight
                }
            }
        }), b.defaults({
            scroller: H
        });
        var ed = b.getAll().filter(function(e) {
            return e.scroller === p || e.scroller === H
        });
        ed.forEach(function(e) {
            return e.revert(!0, !0)
        }), L = b.create({
            animation: u.fromTo(ec, {
                y: function e() {
                    return j = 0
                }
            }, {
                y: function e() {
                    return j = 1, -eu()
                },
                immediateRender: !1,
                ease: "none",
                data: "ScrollSmoother",
                duration: 100,
                onUpdate: function e() {
                    if (j) {
                        var t = K;
                        t && (n(L), ec.y = es), i(ec.y, t), _(), J && !M && J(e_)
                    }
                }
            }),
            onRefreshInit: function e(t) {
                if (!A.isRefreshing) {
                    if (A.isRefreshing = !0, O) {
                        var _ = b.getAll().filter(function(e) {
                            return !!e.pin
                        });
                        O.forEach(function(e) {
                            e.vars.pinnedContainer || _.forEach(function(t) {
                                if (t.pin.contains(e.trigger)) {
                                    var _ = e.vars;
                                    _.pinnedContainer = t.pin, e.vars = null, e.init(_, e.animation)
                                }
                            })
                        })
                    }
                    var r = t.getTween();
                    Y = r && r._end > r._dp._time, F = es, ec.y = 0, eo && (1 === b.isTouch && (H.style.position = "absolute"), H.scrollTop = 0, 1 === b.isTouch && (H.style.position = "fixed"))
                }
            },
            onRefresh: function e(t) {
                t.animation.invalidate(), t.setPositions(t.start, eu() / ei), Y || n(t), ec.y = -en() * ei, i(ec.y), e$ || (Y && (K = !1), t.animation.progress(u.utils.clamp(0, 1, -(F / ei / t.end)))), Y && (t.progress -= .001, t.update()), A.isRefreshing = !1
            },
            id: "ScrollSmoother",
            scroller: p,
            invalidateOnRefresh: !0,
            start: 0,
            refreshPriority: -9999,
            end: function e() {
                return eu() / ei
            },
            onScrubComplete: function e() {
                el.reset(), Q && Q(t)
            },
            scrub: eo || !0
        }), this.smooth = function(t) {
            return arguments.length && (ei = (eo = t || 0) && +e.speed || 1, L.scrubDuration(t)), L.getTween() ? L.getTween().duration() : 0
        }, L.getTween() && (L.getTween().vars.ease = e.ease || S), this.scrollTrigger = L, e.effects && this.effects(!0 === e.effects ? "[data-" + er + "speed], [data-" + er + "lag]" : e.effects, {
            effectsPadding: e.effectsPadding,
            refresh: !1
        }), e.sections && this.sections(!0 === e.sections ? "[data-section]" : e.sections), ed.forEach(function(e) {
            e.vars.scroller = H, e.revert(!1, !0), e.init(e.vars, e.animation)
        }), this.paused = function(e, t) {
            return arguments.length ? (!!M !== e && (e ? (L.getTween() && L.getTween().pause(), en(-es / ei), el.reset(), (q = b.normalizeScroll()) && q.disable(), (M = b.observe({
                preventDefault: !0,
                type: "wheel,touch,scroll",
                debounce: !1,
                allowClicks: !0,
                onChangeY: function e() {
                    return s(-es)
                }
            })).nested = x(g, "wheel,touch,scroll", !0, !1 !== t)) : (M.nested.kill(), M.kill(), M = 0, q && q.enable(), L.progress = (-es / ei - L.start) / (L.end - L.start), n(L))), this) : !!M
        }, this.kill = this.revert = function() {
            t.paused(!1), n(L), L.kill();
            for (var e = (O || []).concat(I || []), _ = e.length; _--;) e[_].kill();
            b.scrollerProxy(H), b.removeEventListener("killAll", f), b.removeEventListener("refresh", c), H.style.cssText = V, B.style.cssText = D;
            var r = b.defaults({});
            r && r.scroller === H && b.defaults({
                scroller: p
            }), t.normalizer && b.normalizeScroll(!1), clearInterval(U), w = null, ef && ef.disconnect(), v.style.removeProperty("height"), p.removeEventListener("focusin", a)
        }, this.refresh = function(e, t) {
            return L.refresh(e, t)
        }, ee && (this.normalizer = b.normalizeScroll(!0 === ee ? {
            debounce: !0,
            content: !eo && B
        } : ee)), b.config(e), "overscrollBehavior" in p.getComputedStyle(v) && u.set([v, g], {
            overscrollBehavior: "none"
        }), "scrollBehavior" in p.getComputedStyle(v) && u.set([v, g], {
            scrollBehavior: "auto"
        }), p.addEventListener("focusin", a), U = setInterval(_, 250), "loading" === h.readyState || requestAnimationFrame(function() {
            return b.refresh()
        })
    }
    R.version = "3.12.5", R.create = function(e) {
        return w && e && w.content() === m(e.content)[0] ? w : new R(e)
    }, R.get = function() {
        return w
    }, r() && u.registerPlugin(R), e.ScrollSmoother = R, e.default = R, "undefined" == typeof window || window !== e ? Object.defineProperty(e, "__esModule", {
        value: !0
    }) : delete e.default
});